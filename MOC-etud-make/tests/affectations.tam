; Generated code for tests/affectations.moc.
; Do not modify by hand
	; code in inline : start
; inline code_asm


	CALL (LB) _main


	HALT


	; code in inline : end
_fRetour:
	; if
	; acces a a
	LOAD (1) -1[LB]
	JUMPIF(0) label1
	; then
	; retour
	; acces a a
	LOAD (1) -1[LB]
	RETURN (1) 1
	; fin retour
	POP(0) 0

	JUMP label0
	; else
label1 :
	; retour
	LOADL 19	; entier
	RETURN (1) 1
	; fin retour
	POP(0) 0

label0 :
	; end if
	POP(0) 0

_fDecl:
	; declaration sans initialisation de x de taille 1 en [3/Register [name=LB, num=0]]
	PUSH 1
	; declaration sans initialisation de y de taille 1 en [4/Register [name=LB, num=0]]
	PUSH 1
	LOADL 2	; entier
	STORE(1) 4[LB]
	; declaration sans initialisation de c de taille 1 en [5/Register [name=LB, num=0]]
	PUSH 1
	LOADL 'e'	; caractere
	STORE(1) 5[LB]
	; declaration sans initialisation de z de taille 1 en [6/Register [name=LB, num=0]]
	PUSH 1
	; acces a y
	LOAD (1) 4[LB]
	STORE(1) 6[LB]
	POP(0) 4

	; retour
	RETURN (0) 0
	; fin retour
_main:
	; declaration sans initialisation de a de taille 1 en [3/Register [name=LB, num=0]]
	PUSH 1
	LOADL 1	; entier
	STORE(1) 3[LB]
	; empilement des parametres
	; Appel de fDecl
	CALL(SB) _fDecl
	POP(0) 0
	; declaration sans initialisation de b de taille 1 en [4/Register [name=LB, num=0]]
	PUSH 1
	; declaration sans initialisation de d4 de taille 1 en [5/Register [name=LB, num=0]]
	PUSH 1
	; empilement des parametres
	; empilement des parametres
	; parametre de sous-programme
	LOADL 4	; entier
	; charger le parametre ?
	; Appel de fRetour
	CALL(SB) _fRetour
	STORE(1) 5[LB]
	; declaration sans initialisation de d19 de taille 1 en [6/Register [name=LB, num=0]]
	PUSH 1
	; empilement des parametres
	; empilement des parametres
	; parametre de sous-programme
	LOADL 0	; entier
	; charger le parametre ?
	; Appel de fRetour
	CALL(SB) _fRetour
	STORE(1) 6[LB]
	; retour
	LOADL 2	; entier
	LOADL 5	; entier
	SUBR IMul
	LOADL 3	; entier
	SUBR IMul
	LOADL 5	; entier
	SUBR IDiv
	RETURN (0) 1
	; fin retour
	POP(0) 4

